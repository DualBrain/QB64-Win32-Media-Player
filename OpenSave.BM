Function ComDlgFileName$ (__Title As String, InitialDir As String, Filter As String, FilterIndex As _Unsigned Long, Flags As _Unsigned Long)
    Type OPENFILENAME
        As _Unsigned Long lStructSize
        $If 64BIT Then
            As String * 4 padding
        $End If
        As _Offset hwndOwner, hInstance, lpstrFilter, lpstrCustomFilter
        As _Unsigned Long nMaxCustFilter, nFilterIndex
        As _Offset lpstrFile
        As _Unsigned Long nMaxFile
        $If 64BIT Then
            As String * 4 padding2
        $End If
        As _Offset lpstrFile__Title
        As _Unsigned Long nMaxFile__Title
        $If 64BIT Then
            As String * 4 padding3
        $End If
        As _Offset lpstrInitialDir, lpstr__Title
        As _Unsigned Long Flags
        As Integer nFileOffset, nFileExtension
        As _Offset lpstrDefExt, lCustData, lpfnHook, lpTemplateName, pvReserved
        As _Unsigned Long dwReserved, FlagsEx
    End Type

    Declare Dynamic Library "Comdlg32"
        $If UNICODE = DEFINED Then
        Sub GetSaveFileName Alias "GetSaveFileNameW" (ByVal ofn As _Offset)
        Function GetOpenFileName& Alias "GetOpenFileNameW" (ByVal ofn As _Offset)
        $Else
            Sub GetSaveFileName Alias "GetSaveFileNameA" (ByVal ofn As _Offset)
            Function GetOpenFileName& Alias "GetOpenFileNameA" (ByVal ofn As _Offset)
        $End If
    End Declare

    $If UNICODE = DEFINED Then
        Declare CustomType Library
        Function wcslen%& (ByVal str As _Offset)
        End Declare
    $Else
        $If 64BIT Then
            Declare CustomType Library ".\internal\c\c_compiler\x86_64-w64-mingw32\include\tchar"
                Function tcslen%& Alias "_tcslen" (ByVal str As _Offset)
            End Declare
        $Else
            Declare CustomType Library ".\internal\c\c_compiler\i686-w64-mingw32\include\tchar"
            Function tcslen%& Alias "_tcslen" (ByVal str As _Offset)
            End Declare
        $End If
    $End If

    Dim As OPENFILENAME ofn
    Do
        Mid$(Filter, InStr(Filter, "|")) = Chr$(0)
    Loop While InStr(Filter, "|")

    $If UNICODE = DEFINED Then
        __Title = ANSIToUnicode(__Title + Chr$(0))
        InitialDir = ANSIToUnicode(InitialDir + Chr$(0))
        Filter = ANSIToUnicode(Filter + Chr$(0) + Chr$(0))
    $Else
        __Title = __Title + Chr$(0)
        InitialDir = InitialDir + Chr$(0)
        Filter = Filter + Chr$(0) + Chr$(0)
    $End If
    Dim As String * MAX_PATH oFile
    ofn.lStructSize = Len(ofn)
    ofn.hwndOwner = _WindowHandle
    ofn.lpstrFilter = _Offset(Filter)
    ofn.nFilterIndex = FilterIndex
    ofn.nMaxFile = Len(oFile)
    ofn.lpstrFile__Title = ofn.lpstrFile
    ofn.nMaxFile__Title = ofn.nMaxFile
    ofn.lpstrInitialDir = _Offset(InitialDir)
    ofn.lpstr__Title = _Offset(__Title)
    ofn.lpstrFile = _Offset(oFile)
    If OPEN_DIALOG And Flags Or (SAVE_DIALOG And Flags) = 0 Then
        If OFN_ALLOWMULTISELECT And Flags Then Flags = Flags Or OFN_EXPLORER
        Flags = Flags Or OFN_HIDEREADONLY
        ofn.Flags = Flags
        If GetOpenFileName(_Offset(ofn)) <> 0 Then
            If OFN_ALLOWMULTISELECT And Flags Then
                Dim As String file, outfiles, directory
                $If UNICODE = DEFINED Then
                    Dim As _Offset tmp: tmp = ofn.lpstrFile + (ofn.nFileOffset * 2)
                    Dim As _MEM pFiles: pFiles = _Mem(tmp, wcslen(tmp) * 2)
                    Dim As _MEM dir: dir = _Mem(ofn.lpstrFile, wcslen(ofn.lpstrFile) * 2)
                    directory = Space$(wcslen(ofn.lpstrFile) * 2)
                $Else
                    Dim As _Offset tmp: tmp = ofn.lpstrFile + ofn.nFileOffset
                    Dim As _MEM pFiles: pFiles = _Mem(tmp, tcslen(tmp))
                    Dim As _MEM dir: dir = _Mem(ofn.lpstrFile, tcslen(ofn.lpstrFile))
                    directory = Space$(tcslen(ofn.lpstrFile))
                $End If
                _MemGet dir, dir.OFFSET, directory
                _MemFree dir
                Dim As Long i
                $If UNICODE = DEFINED Then
                    While wcslen(tmp)
                    file = Space$(wcslen(tmp) * 2)
                    _MemGet pFiles, pFiles.OFFSET, file
                    Select Case i
                    Case 0
                    outfiles = directory + ANSIToUnicode("\") + file
                    Case Else
                    outfiles = outfiles + ANSIToUnicode("|") + directory + ANSIToUnicode("\") + file
                    End Select
                    i = i + 1
                    tmp = tmp + Len(file) + 2
                    pFiles = _Mem(tmp, wcslen(tmp) * 2)
                    Wend
                $Else
                    While tcslen(tmp)
                        file = Space$(tcslen(tmp))
                        _MemGet pFiles, pFiles.OFFSET, file
                        Select Case i
                            Case 0
                                outfiles = directory + "\" + file
                            Case Else
                                outfiles = outfiles + "|" + directory + "\" + file
                        End Select
                        i = i + 1
                        tmp = tmp + (tcslen(tmp) + 1)
                        pFiles = _Mem(tmp, tcslen(tmp))
                    Wend
                $End If
                _MemFree pFiles
                If i = 1 Then
                    $If UNICODE = DEFINED Then
                        file = wCharPtrToString(_Offset(directory))
                    $Else
                        file = directory
                    $End If
                    ComDlgFileName = file
                Else
                    $If UNICODE = DEFINED Then
                        outfiles = wCharPtrToString(_Offset(outfiles))
                    $End If
                    ComDlgFileName = outfiles
                End If
            Else
                $If UNICODE = DEFINED Then
                    Dim As String selectedfile: selectedfile = wCharPtrToString(_Offset(oFile))
                    ComDlgFileName = selectedfile
                $Else
                    ComDlgFileName = Mid$(oFile, 1, InStr(oFile, Chr$(0)) - 1)
                $End If
            End If
        End If
    ElseIf SAVE_DIALOG And Flags Then
        ofn.Flags = Flags
        Dim As String defaultExt:defaultExt = DEFEXT
        ofn.lpstrDefExt =  _Offset(defaultExt)
        GetSaveFileName _Offset(ofn)
        $If UNICODE = DEFINED Then
            selectedfile = wCharPtrToString(_Offset(oFile))
            ComDlgFileName = selectedfile
        $Else
            ComDlgFileName = Mid$(oFile, 1, InStr(oFile, Chr$(0)) - 1)
        $End If
    End If
End Function

Function SelectFolder$ (__Title As String)
    Type BROWSEINFO
        As _Offset hwndOwner, pidlRoot, pszDisplayName, lpsz__Title
        As _Unsigned Long ulFlags
        As _Offset lpfn, lParam
        As Long iImage
    End Type
    Declare Dynamic Library "Shell32"
        $If UNICODE = DEFINED Then
        Function SHBrowseForFolder%& Alias "SHBrowseForFolderW" (ByVal lpbi As _Offset)
        Function SHGetPathFromIDList%% Alias "SHGetPathFromIDListW" (ByVal lpItem As _Offset, Byval szDir As _Offset)
        $Else
            Function SHBrowseForFolder%& (ByVal lpbi As _Offset)
            Function SHGetPathFromIDList%% (ByVal lpItem As _Offset, Byval szDir As _Offset)
        $End If
    End Declare
    Dim As BROWSEINFO browse
    Dim As String * MAX_PATH folder
    $If UNICODE = DEFINED Then
        __Title = ANSIToUnicode(__Title + Chr$(0))
    $Else
        __Title = __Title + Chr$(0)
    $End If
    browse.hwndOwner = _WindowHandle
    browse.pszDisplayName = _Offset(folder)
    browse.lpsz__Title = _Offset(__Title)
    Dim As _Offset pfolder
    pfolder = SHBrowseForFolder(_Offset(browse))
    If pfolder Then
        Dim As String * MAX_PATH resolvedPath
        If SHGetPathFromIDList(pfolder, _Offset(resolvedPath)) Then
            $If UNICODE = DEFINED Then
                SelectFolder = wCharPtrToString(_Offset(resolvedPath))
            $Else
                SelectFolder = Mid$(resolvedPath, 1, InStr(resolvedPath, Chr$(0)) - 1)
            $End If
        End If
    End If
End Function

$If UNICODE = DEFINED Then
    Function wCharPtrToString$ (wchar As _Offset)
    Dim As _Offset wlen: wlen = wcslen(wchar) * 2 'The length does not account for the 2-byte nature of Unicode so we multiply by 2
    Dim As _MEM pChar: pChar = _Mem(wchar, wlen) 'Declaring a new _MEM block and setting it to grab the number of bytes referenced by wlen at pointer wchar
    Dim As String char: char = Space$(wlen) 'Declaring a new string large enough to hold the unicode string
    _MemGet pChar, pChar.OFFSET, char 'Storing the data in the string
    _MemFree pChar 'Freeing the _MEM block
    wCharPtrToString = UnicodeToANSI(char) 'Returning the converted Unicode string
    End Function

    '$INCLUDE:'unicodetoansi.bas'
$End If
